#
#   Python backend and Angular frontend code generation by gencrud
#   Copyright (C) 2018-2020 Marc Bertens-Nguyen m.bertens@pe2mbs.nl
#
#   This library is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Library General Public License GPL-2.0-only
#   as published by the Free Software Foundation.
#
#   This library is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#   Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License GPL-2.0-only along with this library; if not, write to the
#   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
#   Boston, MA 02110-1301 USA
#
#   gencrud: 2020-12-05 15:21:29 version 2.0.607 by user mbertens
#
import webapp2.api as API
from sqlalchemy import event
import webapp2.common   as common


# Needed during version migration
db = API.db

class Role( API.db.Model
                ):
    """Model for the gn_role table, this is generated by the gencrud.py module
    When modifing the file make sure that you remove the table from the configuration.
    """
    __tablename__        = 'gn_role'
    R_ID                 = db.Column( "r_id", db.Integer, autoincrement = True, primary_key = True )
    R_ROLE               = db.Column( "r_role", db.String( 255 ), nullable = False )
    R_MOD                = db.Column( "r_mod", db.DateTime, nullable = False, default = common.getCurrentUtcDateTime() )
    R_USER_MOD           = db.Column( "r_user_mod", db.String( 30 ), nullable = False, default = common.getCurrentUser() )
    R_REMARK             = db.Column( "r_remark", db.LONGTEXT, nullable = True )


    def memoryInstance( self ):
        return RoleMemory( self )

    def toDict( self ):
        return self.dictionary

    @property
    def dictionary( self ):
        return {
             "R_ID": self.R_ID,
             "R_ROLE": self.R_ROLE,
             "R_MOD": self.R_MOD,
             "R_USER_MOD": self.R_USER_MOD,
             "R_REMARK": self.R_REMARK,
        }

    def toSql( self ):
        data = self.dictionary
        values = repr( data.values() ).split( '[' )[ 1 ].split( ']' )[ 0 ]
        return "INSERT INTO {} ( {} ) VALUES ( {} )".format( self.__tablename__,
                                                             ", ".join( data.keys() ),
                                                             values )

    def __repr__( self ):
        result_fields = []
        result_fields.append( "R_ID = {}".format( self.R_ID ) )
        result_fields.append( "R_ROLE = {}".format( self.R_ROLE ) )
        result_fields.append( "R_MOD = {}".format( self.R_MOD ) )
        result_fields.append( "R_USER_MOD = {}".format( self.R_USER_MOD ) )
        result_fields.append( "R_REMARK = {}".format( self.R_REMARK ) )
        return "<Role {}>".format( ", ".join( result_fields ) )

    def __str__( self ):
        return self.__repr__()

# standard decorator style
@event.listens_for( Role, 'before_update')
def receive_before_commit( mapper, connection, record ):
    record.R_MOD = common.getCurrentUtcDateTime()
    record.R_USER_MOD = common.getCurrentUser()
    return


class RoleMemory( object ):
    def __init__( self, record = None, *args, **kwargs ):
        self.clear()
        self.set( record, **kwargs )
        return

    def clear( self ):
        self.R_ID                     = None
        self.R_ROLE                   = None
        self.R_MOD                    = None
        self.R_USER_MOD               = None
        self.R_REMARK                 = None
        return

    def set( self, record = None, **kwargs ):
        if isinstance( record, Role ):
            self.R_ID                 = record.R_ID
            self.R_ROLE               = record.R_ROLE
            self.R_MOD                = record.R_MOD
            self.R_USER_MOD           = record.R_USER_MOD
            self.R_REMARK             = record.R_REMARK
        for key, value in kwargs.items():
            setattr( self, key, value )

        return

    @classmethod
    def fetch( cls, *args, **kwargs ):
        query = API.db.session.query( Role )
        for condition in args:
            query = query.filter( condition )

        return cls( query.one() )

    @classmethod
    def fetch_many( cls, *args, **kwargs ):
        result = []
        query = API.db.session.query( Role )
        for condition in args:
            query = query.filter( condition )

        if 'order_by' in kwargs:
            query = query.order_by( kwargs[ 'order_by' ] + " " + kwargs.get( 'order_dir', 'asc' ) )

        return [ cls( record ) for record in query.all() ]

    def __repr__( self ):
        result = "<RoleMemory "
        result += "R_ID = {}, ".format( self.R_ID )
        result += "R_ROLE = {}, ".format( self.R_ROLE )
        result += "R_MOD = {}, ".format( self.R_MOD )
        result += "R_USER_MOD = {}, ".format( self.R_USER_MOD )
        result += "R_REMARK = {}, ".format( self.R_REMARK )
        result += ">"
        return result

    def __str__( self ):
        return self.__repr__()

    @property
    def dictionary( self ):
        return {
             "R_ID": self.R_ID,
             "R_ROLE": self.R_ROLE,
             "R_MOD": self.R_MOD,
             "R_USER_MOD": self.R_USER_MOD,
             "R_REMARK": self.R_REMARK,
        }

